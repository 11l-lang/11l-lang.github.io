[[[Н‘Операторы’
]]]Н‘Операторы’


Таблица всех операторов 11l в порядке от наивысшего приоритета к низшему:
Т‘‘
‘x.y
module:f
0‘a[x]’
f(x)
x--
x++
’
‘Доступ к элементу
Функция или переменная модуля
Обращение к элементу контейнера
Вызов функции
Постфиксный декремент
Постфиксный инкремент’’
‘‘^’ ‘Оператор возведения в степень (ассоциативность: справа налево)’’
‘‘-x
+x
!x
(-)x
--x
++x
’ ‘Унарный минус
Унарный плюс
Логическое НЕ
Поразрядное НЕ (обоснование выбора: {
Оператор (-) является парным оператору XOR (+) и обладает следующими свойствами:
a(-)b = NOT (a XOR b)
NOT a = 0(-)a = (-)a
a(-)(-)b = a(+)b
a(+)(-)b = a(-)b
(-)(-)a = a

Однако так как бинарный оператор (-) не имеет аппаратной поддержки и используется крайне редко, в 11l включён только унарный оператор (-), который соответствует поразрядному НЕ.
})
Префиксный декремент
Префиксный инкремент’’
‘‘x * y
x / y
x I/ y или x Ц/ y
x % y
’ ‘Умножение
Деление
Целочисленное деление
Остаток от деления’’
‘‘x + y
x - y’ ‘Сложение
Вычитание’’
‘‘x << y
x >> y’ ‘Поразрядный сдвиг влево
Поразрядный сдвиг вправо’’
‘‘x 0‘[&]’ y’ ‘Поразрядное И (обоснование выбора: {
0‘[&]’ выглядит похоже на логический вентиль И:

Р‘https://upload.wikimedia.org/wikipedia/commons/thumb/c/c2/IEC_AND_label.svg/100px-IEC_AND_label.svg.png’
})’’
‘‘x (+) y’ ‘Поразрядное исключающее ИЛИ (обоснование выбора: {
Символы (+) похожи на символ ⊕, который используется в ‘алгебре логики’[https://ru.wikipedia.org/wiki/Алгебра_логики]\‘Boolean algebra’[https://en.wikipedia.org/wiki/Boolean_algebra] для обозначения операции ‘исключающего или’/‘сложения по модулю 2’[https://ru.wikipedia.org/wiki/Сложение_по_модулю_2]: Р‘https://wikimedia.org/api/rest_v1/media/math/render/svg/18f7d86510aec2e45bb019abacccd2e772790f8f’.
И хотя ⊕ используется чаще для [[[однобитовых/]]]одноразрядных значений, в Википедии встречается его применение ‘для указателей’[https://ru.wikipedia.org/wiki/XOR-связный_список <- https://habrahabr.ru/post/183462/#comment_6377452 <- google:‘1с xor’] и ‘для массивов из байт’[https://en.wikipedia.org/wiki/Hash-based_message_authentication_code <- google:‘HMAC’ <- https://www.imperialviolet.org/2017/05/31/skipsha3.html ‘key:        Bytes     array of bytes’].
[К тому же, использовать ^ для данной операции я считаю неудачной идеей (ну, во всяком случае новичков в программировании это точно ‘сбивает с толку’[https://stackoverflow.com/questions/11464905/what-is-used-for-in-ruby]).]
})’’
‘‘x 0‘[|]’ y’ ‘Поразрядное ИЛИ (обоснование выбора: {
Символ | похож на 1, а 0‘[1]’ выглядит похоже на логический вентиль ИЛИ:

Р‘https://upload.wikimedia.org/wikipedia/commons/thumb/3/3f/OR_gate_RU.svg/100px-OR_gate_RU.svg.png’[https://ru.wikipedia.org/wiki/Логические_элементы#Дизъюнкция_(логическое_сложение)._Операция_ИЛИ]
})’’
‘‘x < y, x <= y
x > y, x >= y’ ‘Операции сравнения’’
‘‘x..y, x.<y
x<.y, x<.<y’ ‘Диапазоны[[[
a..b соответствует [a, b] в языках программирования: Ruby[‘TIOBE Rating: 1.091%’], Kotlin[‘0.216%’]
a...b соответствует [a, b] в языках программирования: Swift[‘1.455%’][[[(]]]
a..b соответствует [a, b) в языках программирования: D[‘0.681%’], Rust[‘0.251%’]'‘<!--]-->’'
]]]’’
‘‘x""y и x‘’y’ ‘Конкатенация строк (‘обоснование выбора’[./../‘’])’’
‘‘x == y, x != y
e in c, e !in c
e C c, e !C c
’ ‘Сравнения
Элемент e содержится/‘не содержится’ в контейнере c’’
‘‘x & y’ ‘Логическое И (обоснование выбора: {
Используется `&` вместо `&&` так как логическое И требуется гораздо[[[/намного]]] чаще, чем поразрядное.
})’’
‘‘x | y’ ‘Логическое ИЛИ’’
‘‘x ? y’ ‘Вернуть левый операнд если он не нуль, иначе вернуть правый операнд’’
‘‘() -> выражение
x -> выражение
(x, y) -> выражение’ ‘Лямбда выражение’’
‘‘arr1 0‘[+]’ arr2’ ‘Конкатенация массивов (обоснование выбора: {
Так как массивы задаются с использованием квадратных скобок: `[1, 2, ...]`.
Так как эта операция достаточно дорогая, ей выделен [[[специальный/]]]отдельный оператор.
})’’
‘‘x = ...
x += ...
-= *= /= I/= Ц/=
%= >>= <<= ^=
0‘[+]= [&]= [|]=’
(+)= ‘’=’ ‘Присваивания (ассоциативность: справа налево)’’
’
