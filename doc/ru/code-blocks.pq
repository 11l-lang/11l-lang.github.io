[[[Н‘Блоки кода’
]]]Н‘Блоки кода’


Также как и в Python, блоки кода в 11l выделяются посредством отступов (пробелов или табуляций):
#(11l)‘
F sum(a, b)
   R a + b
’
[Здесь объявляется функция `sum`, возвращающая сумму двух её аргументов.]

Но 11l также поддерживает явное обозначение блоков посредством фигурных скобок, благодаря которому можно объявить эту же функцию без отступа:
#(11l)‘
F sum(a, b)
{
R a + b
}
’

или в одну строку:
#(11l)‘
F sum(a, b) {R a + b}
’

И такой стиль также поддерживается:
#(11l)‘
F sum(a, b) {
   R a + b
}
’

И такой:
#(11l)‘
F sum(a, b) {
R a + b
}
’

И такой:
#(11l)‘
F sum(a, b)
{
   R a + b
}
’

‘Мои мысли на тему ‘whitespace indentation to delimit code blocks’\‘выделение блоков кода с помощью отступов’/‘«двухмерного» синтаксиса Python-а’’{
«Двухмерный» синтаксис помимо избавления от [мелкого] синтаксического '‘<s>’'сахара'‘</s>’'мусора {в форме [[[точек с запятой, а также ]]точки с запятой не имеют отношения к «двухмерному» синтаксису (существует множество языков программирования с необязательными точками с запятой, но без выделения блоков кода с помощью отступов: JavaScript, Go, Swift, Scala, Groovy, Kotlin)]ключевых слов begin/end или фигурных скобок} даёт нечто большее, но что ещё так и не увидели/не поняли многие разработчики.
Проиллюстрирую это на примере документации к языку Nemerle:
>[https://github.com/rsdn/nemerle/wiki/The-basics-(tutorial)#Rewriting_Line_Counter_without_the_loop]:‘
In Nemerle the if expression always need to have the else clause. It's done this way to avoid stupid bugs with dangling-else:
#(11l)‘
// C#, misleading indentation hides real code meaning
if (foo)
   if (bar)
     m1 ();
else
   m2 ();
’
If you do not want the `else` clause, use `when` expression, as seen in the example.’

Скорее всего, разработчики Nemerle просто ‘скопировали это из Haskell или Standard ML’[https://semitwist.com/articles/article/view/nemerle-s-when-bad-idea-easily-solved ‘The mandatory 'else' is Nemerle's functional language inheritance showing’], не став даже разбираться в причинах указанного "stupid bug with dangling-else". А причина вовсе не в неправильной логике if [допускающем как отсутствие ветви else, так и её наличие], и даже не в забытых фигурных скобочках, а в... расхождении в восприятии данного кода человеком-программистом и компилятором. Человек воспринимает границы блоков визуально, [[[в первую очередь ]]]посредством отступов, а компилятор — посредством [малоприметных для человека] символов, причём компилятор [языков C/C++, C#, Java, Nemerle и др.] объединяет все "пробельные" символы [разделители], и, таким образом, напрочь игнорирует отступы. Вот в этом и заключается '‘<b>’'корень проблемы — компилятор и человек видят [такой] код по-разному'‘</b>’'.
Поэтому меня удивляют люди, которые ‘‘жалуются на трудность и непривычность чтения такого кода’’, а также возражения, что ‘‘при изменении лишь отступа, меняется логика работы кода’’. Так в этом и состоит весь смысл отступо-зависимой семантики! Ведь такое изменение отступа будет хорошо заметно человеку (особенно привыкшему к такой семантике).
А для желающих временно добавить if, включающий в себя большой блок кода [который не хочется сдвигать лишний раз], я считаю, что вполне можно оставить поддержку фигурных скобок:
#(11l)‘
if foo // временно добавленное условие
{
m1() // нет отступа относительно if foo
...
if bar
    m2()
    ...
...
}
’

>[http://compiler.su/dvukhmernyj-sintaksis-python.php]:‘... заканчиваются двоеточием, без которого можно обойтись.’
Согласен.
По сути, это двоеточие в Python не имеет смысла, так как есть операторы (if, [[[switch, ]]]for/while, def, class и т.д.), которые требуют всегда нового scope, и одного признака ‘‘новая строка с отступом’’ вполне достаточно.
‘Кстати, весьма интересна история появления этого двоеточия.’{
>[http://python-history.blogspot.com/2011/07/karin-dewar-indentation-and-colon.html ‘Karin Dewar, Indentation and the Colon’]:‘
In 1978, in a design session in a mansion in Jabłonna (Poland), Robert Dewar, Peter King, Jack Schwartz and Lambert were comparing various alternative proposed syntaxes for B[[[, by comparing (buggy) bubble sort implementations written down in each alternative]]]... Since they couldn't agree, Robert Dewar's wife was called from her room and asked for her opinion[[[, like a modern-day Paris asked to compare the beauty of Hera, Athena, and Aphrodite]]]... But after the first version was explained to her, she remarked: "You mean, in the line where it says: 'FOR i ... ', that it has to be done for the lines that follow; not just for that line?!" And here the scientists realized that the misunderstanding would have been avoided if there had been a colon at the end of that line.
’
То есть, scientists, разработчики языка программирования, прислушались к мнению[[[/высказыванию]]] [[[женщины/]]]человека, не имеющего никакого отношения к программированию? Они хотели таким образом упростить понимание языка для новичков? Но новичком программист остаётся только короткое время в начале своего пути, а лишние двоеточия наблюдать и набирать придётся и дальше. Не думаю, что так уж сложно [[[будет ]]]привыкнуть к их отсутствию...
}
Единственное полезное применение двоеточия — однострочные if'ы (`if условие: выражение`) и циклы, но [[[это вполне можно разрулить /]]]выйти из положения можно с помощью обозначения scope в фигурных скобках (запись `if условие {выражение}`) как в Rust, либо взяв условие в скобки (`if (условие) выражение`).
В крайнем случае, я считаю, вполне возможно это двоеточие [[[отображать по настройке в IDE]]]вынести в настройки проекта. И команды разработчиков, которые примут у себя в качестве стандарта [кодирования] запись с двоеточием, будут писать с двоеточием, а кто не хочет [следовать такому стандарту] — пусть пишут без двоеточия. На уровне компилятора реализовать пропуск двоеточия ~‘в конце строки’ для [[[некоторых/]]]нескольких операторов [[[задача элементарная]]]совсем несложно.
Или можно на уровне IDE сделать опциальное отображение двоеточия в конце строк, начинающихся на I/if, E/else, F/fn, L/loop, S/switch, T/type и т.д.
}
