[[[Н‘Строковые литералы’
]]]Н‘Обычные строковые литералы’


Заключаются в двойные кавычки (символ `"`).
Поддерживают управляющие [[[символы/]]]последовательности такие же как в языке C++ (`\n`, `\t` и т.д.).


Н‘"Сырые" строковые литералы’


Заключаются в одиночные парные кавычки — символы `‘` и `’`.
Как такие кавычки набирать на клавиатуре — смотрите здесь[http://pqmarkup.org/ru].
!‘Если у вас остались сложности с набором символов `‘` и `’`, можно использовать диграфы `'"` и `"'`. Однако, обратите внимание, что эти диграфы не являются частью языка 11l. Они существуют только для [[[удобства/]]]облегчения/упрощения[[[/простоты]]] набора, и будут заменены на `‘` и `’` в вашем исходном 11l-файле на этапе лексического анализа.’

Если в строке присутствуют непарные кавычки, тогда нужно выполнить балансировку строки аналогично тому, как это делается в пк-разметке для вставки HTML-кода (смотри ‘Дополнительные возможности форматирования. "Сырой"\Raw HTML’[http://pqmarkup.org/ru/syntax]).
Например есть строка [[[‘]]]`don’t`.
Так как в ней присутствует несбалансированная закрывающая кавычка, добавим балансирующую открывающую кавычку в самое начало строки: С(080)‘‘[[[’]]]’[[[‘]]]don’t.
Сбалансированную строку заключаем в парные кавычки: С(080)‘‘[[[’]]]’‘don’tС(080)‘[[[‘]]]’’.
Теперь необходимо как-то показать парсеру, что добавленную слева кавычку не следует включать в строку, так как она нужна только для восстановления баланса. Для этого используется символ машинописного апострофа `'`, который нужно поставить по одной штуке на каждую балансирующую кавычку [таким образом, один машинописный апостроф "съедает" одну парную кавычку], в данном случае его необходимо поставить в начало строки: #‘'‘‘don’t’’.
Сбалансированную строку (например, #(11l)‘'‘‘don’t’’) можно как есть вставлять в другие строки в парных кавычках:
#‘‘text = '‘‘don’t’’’.


Н‘Многострочные строковые литералы с отступом’


Также как в языках Swift[https://docs.swift.org/swift-book/LanguageGuide/StringsAndCharacters.html] и Julia[https://docs.julialang.org/en/v1/manual/strings/#Triple-Quoted-String-Literals] многострочные строковые литералы в 11l могут содержать отступ, чтобы соответствовать окружающему коду.
[Заметьте, что в Swift и Julia то, как работают многострочные строковые литералы, немного отличается: {
#(Python)‘
"""
hello
"""
’
эквивалентно #(Python)‘"hello"’ в Swift и #(Python)‘"hello\n"’ в Julia.
}]

Просто добавьте символ `|` перед строковым литералом:
#(11l)‘
V str = |‘First line.
          Second line.’
’
Это эквивалентно
#(11l)‘
V str = "First line.\nSecond line."
’


Н‘Многострочные строковые литералы с нулевым отступом’


T‘H‘‘Python’ ‘11l’’
‘><‘pqmarkup.py[https://sourceforge.net/p/pqmarkup/code/ci/b9c7c147afedf42549fc1eab09dfa9b31340b03e/tree/pqmarkup.py#l756]’ -’
‘‘#(Python)‘
if args_output_html_document:
    args_outfile.write('''\
<html>
<head>
...
''')
’’ ‘#(11l)‘
I args_output_html_document
   args_outfile.write(\/‘
<html>
<head>
...
’)
’’’
‘><‘cut_copy_paste_tests.py[https://github.com/alextretyak/CopyEdit/blob/87b0adc0c46ffa349ce879b42f3aacd8d575b71e/cut_copy_paste_tests.py#L12]’ -’
‘‘#(Python)‘
...:
        tests = """\
(1)
1. Select THIS
...
"""
’’ ‘#(11l)‘
...
      V tests = \/‘
(1)
1. Select THIS
...
’
’’’
’

Заметьте, что `\/"..."` не имеет смысла, т.к. можно писать так:
#(11l)‘
tests = "\
...
"
’
А `\/‘...’` нужно по той причине, что в 11l нет `"""..."""`, [[[но/]]]а многострочные строковые литералы часто содержат двойные[[[ или одинарные](закомментировал, т.к. в 11l нет `'таких строк'`)]] кавычки.
