<html>
<head>
<meta charset="utf-8" />
<title>Code blocks</title>
<base target="_blank">
<script type="text/javascript">
function spoiler(element, event)
{
    if (event.target.nodeName == 'A' || event.target.parentNode.nodeName == 'A' || event.target.onclick)//чтобы работали ссылки в спойлерах и спойлеры2 в спойлерах
        return;
    var e = element.firstChild.nextSibling.nextSibling;//element.getElementsByTagName('span')[0]
    e.previousSibling.style.display = e.style.display;//<span>…</span> must have inverted display style
    e.style.display = (e.style.display == "none" ? "" : "none");
    element.firstChild.style.fontWeight =
    element. lastChild.style.fontWeight = (e.style.display == "" ? "normal" : "bold");
    event.stopPropagation();
    //[-Чтобы была возможность выделять текст внутри раскрытого ‘скрытого текста’/спойлера, необходимо [скрытие/]закрытие спойлера делать не просто по нажатию левой кнопки мыши, а по отпусканию левой кнопки мыши при условии отсутствия движения курсора [мыши] после того, как была нажата левая кнопка мыши.-]
}
function spoiler2(element, event)
{
    element.nextSibling.style.display = (element.nextSibling.style.display == "none" ? "" : "none");
}
</script>
<style type="text/css">
body td {
    font-size: 14px;
    font-family: Verdana, sans-serif;
    line-height: 160%;
}
span.cu_brackets_b {
    font-size: initial;
    font-family: initial;
    font-weight: bold;
}
a {
    text-decoration: none;
    color: #6da3bd;
}
a:hover {
    text-decoration: underline;
    color: #4d7285;
}
h1, h2, h3, h4, h5, h6 {
    margin: 0;
    font-weight: 400;
}
h1 {font-size: 190%; line-height: 120%;}
h2 {font-size: 160%;}
h3 {font-size: 137.5%;}
h4 {font-size: 120%;}
h5 {font-size: 110%;}
h6 {font-size: 100%;}
td {text-align: justify; /*font-family: Tahoma, sans-serif;*/}
span.sq {color: gray; font-size: 0.8rem; font-weight: normal; /*pointer-events: none;*/}
span.sq_brackets {color: #BFBFBF;}
span.cu_brackets {cursor: pointer;}
span.cu {background-color: #F7F7FF;}
abbr {text-decoration: none; border-bottom: 1px dotted;}
pre {margin: 0;}
pre, code {font-family: 'Courier New'; line-height: normal}
ul, ol {margin: 11px 0 7px 0;}
ul li, ol li {padding: 7px 0;}
ul li:first-child, ol li:first-child {padding-top   : 0;}
ul  li:last-child, ol  li:last-child {padding-bottom: 0;}
table table {margin: 9px 0; border-collapse: collapse;}
table table th, table table td {padding: 6px 13px; border: 1px solid #BFBFBF;}
span.spoiler_title {
    color: #548eaa;
    cursor: pointer;
    border-bottom: 1px dotted;
}
div.spoiler_text {
    /*border: 1px dotted;*/
    margin: 5px;
    padding: 3px;
}
blockquote {
    margin: 0 0 7px 0;
    padding: 7px 12px;
}
blockquote:not(.re) {border-left:  0.2em solid #90ddaa; background-color: #fbfffb;}
blockquote.re       {border-right: 0.2em solid #90ddaa; background-color: #f4fff8;}
div.note {
    padding: 18px 20px;
    background: #ffffd7;
}
pre.code_block {padding: 6px 0;}
pre.inline_code {
    display: inline;
    padding: 0px 3px;
    border: 1px solid #E5E5E5;
    background-color: #FAFAFA;
    border-radius: 3px;
}
img {vertical-align: middle;}
</style>
</head>
<body>
<table width="55%" align="center"><tr><td>
<!--[[[Н‘Code blocks’
]]]--><h3>Code blocks</h3>
<br />
<br />
Like a Python, 11l uses whitespace indentation to delimit code blocks:<br />
<style>
span.keyword {color: #0000FF; font-weight: bold;}
span.identifier {color: #00009F;}
span.string-literal {color: #800000;}
span.numeric-literal {color: #008000;}
span.constant {color: #008000;}
span.comment {color: #808080;}
</style><pre class="code_block">
<span class="keyword">F</span> <span class="identifier">sum</span>(<span class="identifier">a</span>, <span class="identifier">b</span>)
   <span class="keyword">R</span> <span class="identifier">a</span> + <span class="identifier">b</span>
</pre>
<span class="sq"><span class="sq_brackets">[</span>This code defines a function <pre class="inline_code">sum</pre>, which returns a sum of its arguments.<span class="sq_brackets">]</span></span><br />
<br />
But 11l also supports explicit blocks designation via curly brackets, which makes it possible to define the same function without indentation:<br />
<pre class="code_block">
<span class="keyword">F</span> <span class="identifier">sum</span>(<span class="identifier">a</span>, <span class="identifier">b</span>)
{
<span class="keyword">R</span> <span class="identifier">a</span> + <span class="identifier">b</span>
}
</pre>
<br />
or in one line:<br />
<pre class="code_block">
<span class="keyword">F</span> <span class="identifier">sum</span>(<span class="identifier">a</span>, <span class="identifier">b</span>) {<span class="keyword">R</span> <span class="identifier">a</span> + <span class="identifier">b</span>}
</pre>
<br />
And this style is also supported:<br />
<pre class="code_block">
<span class="keyword">F</span> <span class="identifier">sum</span>(<span class="identifier">a</span>, <span class="identifier">b</span>) {
   <span class="keyword">R</span> <span class="identifier">a</span> + <span class="identifier">b</span>
}
</pre>
<br />
And this:<br />
<pre class="code_block">
<span class="keyword">F</span> <span class="identifier">sum</span>(<span class="identifier">a</span>, <span class="identifier">b</span>) {
<span class="keyword">R</span> <span class="identifier">a</span> + <span class="identifier">b</span>
}
</pre>
<br />
And this:<br />
<pre class="code_block">
<span class="keyword">F</span> <span class="identifier">sum</span>(<span class="identifier">a</span>, <span class="identifier">b</span>)
{
   <span class="keyword">R</span> <span class="identifier">a</span> + <span class="identifier">b</span>
}
</pre>
<br />
<span class="spoiler_title" onclick="return spoiler2(this, event)">My thoughts on whitespace indentation to delimit code blocks<br /></span><div class="spoiler_text" style="display: none">
Whitespace indentation to delimit code blocks gives<!--[[[/delivers]]]--> much more than just <!--[[[deliverance from/]]]-->getting rid of small syntactic <s>sugar</s><!--[[[rubbish/]]]--><!--[[[verbalism/]]]-->noise <span class="sq"><span class="sq_brackets">[</span>in the form of <!--[[[semicolons, and ]]semicolons are not related to whitespace indentation (there are many programming languages with optional semicolons, but without whitespace indentation: JavaScript, Go, Swift, Scala, Groovy, Kotlin)]-->begin/end keywords or curly <!--[[[braces]]]-->brackets<span class="sq_brackets">]</span></span>. But many <!--[[[developers/]]]-->programmers <!--[[[are]]]--> still do not get it.<br />
Consider this sample from Nemerle programming language documentation:<br />
<blockquote><a href="https://github.com/rsdn/nemerle/wiki/The-basics-(tutorial)#Rewriting_Line_Counter_without_the_loop"><i>https://github.com/rsdn/nemerle/wiki/...</i></a>:<br />
<br />
In Nemerle the if expression always need to have the else clause. It's done this way to avoid stupid bugs with dangling-else:<br />
<pre class="code_block">
<span class="comment">// C#, misleading indentation hides real code meaning</span>
<span class="keyword">if</span> (<span class="identifier">foo</span>)
   <span class="keyword">if</span> (<span class="identifier">bar</span>)
     <span class="identifier">m1</span> ();
<span class="keyword">else</span>
   <span class="identifier">m2</span> ();
</pre>
If you do not want the <pre class="inline_code">else</pre> clause, use <pre class="inline_code">when</pre> expression, as seen in the example.</blockquote>
<br />
Most likely, the developers of Nemerle just <a href="https://semitwist.com/articles/article/view/nemerle-s-when-bad-idea-easily-solved" title="The mandatory 'else' is Nemerle's functional language inheritance showing">took this behaviour from Haskell or Standard ML</a> without understanding the reason<!--[[[s]]]--> of that "stupid bug with dangling-else". But reason is not wrong <pre class="inline_code">if</pre> <span class="sq"><span class="sq_brackets">[</span>allowing an absence of <pre class="inline_code">else</pre> clause<span class="sq_brackets">]</span></span>, and even is not forgotten curly brackets. The reason is divergence in perception of this code by human and with compiler. Human perceives block boundaries via indentation, and compiler via <span class="sq"><span class="sq_brackets">[</span>subtle for human<span class="sq_brackets">]</span></span> symbols. That is what <b>the root of the problem is a compiler and a human see <span class="sq"><span class="sq_brackets">[</span>this<span class="sq_brackets">]</span></span> code differently</b>.<br />
And the solution to this problem is <!--[[[the]]]--> delimiting code blocks via whitespace indentation.<br />
<!--[[[Therefore I am surprised by people which complains on whitespace indentation to delimit code blocks and 
]]]--><br />
<blockquote><a href="http://compiler.su/dvukhmernyj-sintaksis-python.php"><i>http://compiler.su/dvukhmernyj-sintaksis-python.php</i></a>:<br />
выражения <pre class="inline_code">for операторы цикла :</pre>, <pre class="inline_code">if условное выражение :</pre>, <pre class="inline_code">else :</pre> заканчиваются двоеточием, без которого можно обойтись.<br />
(statements <pre class="inline_code">for ... :</pre>, <pre class="inline_code">if condition :</pre>, <pre class="inline_code">else :</pre> ends with a colon, which is not very necessary.)</blockquote>
I agree.<br />
Essentially, this colon in Python has no purpose because there are statements (if, <!--[[[switch, ]]]-->for/while, def, class, etc.), which always require a new scope block, and a new line with a larger indentation level is quite sufficient.<br />
<span class="spoiler_title" onclick="return spoiler2(this, event)">By the way, the history of the appearance of this colon is quite interesting.<br /></span><div class="spoiler_text" style="display: none">
<blockquote><a href="http://python-history.blogspot.com/2011/07/karin-dewar-indentation-and-colon.html" title="Karin Dewar, Indentation and the Colon"><i>http://python-history.blogspot.com/2011/07/...</i></a>:<br />
<br />
In 1978, in a design session in a mansion in Jabłonna (Poland), Robert Dewar, Peter King, Jack Schwartz and Lambert were comparing various alternative proposed syntaxes for B<!--[[[, by comparing (buggy) bubble sort implementations written down in each alternative]]]-->... Since they couldn't agree, Robert Dewar's wife was called from her room and asked for her opinion<!--[[[, like a modern-day Paris asked to compare the beauty of Hera, Athena, and Aphrodite]]]-->... But after the first version was explained to her, she remarked: "You mean, in the line where it says: 'FOR i ... ', that it has to be done for the lines that follow; not just for that line?!" And here the scientists realized that the misunderstanding would have been avoided if there had been a colon at the end of that line.<br />
</blockquote>
That is, scientists, the developers of a programming language, heeded the words of someone who has no relation to programming. Did they want to simplify learning language for novices? But a programmer remains a novice only a short time at the beginning of his career, but observing and typing <!--[[[of]]]--> excess colons will have to continue.<!--[[[ Не думаю, что так уж сложно [[[будет ]]]привыкнуть к их отсутствию...]]]--><br />
</div>
The only useful application of colon is one-line if's (<pre class="inline_code">if condition: statement</pre>) and loops, but <!--[[[this can be [[[cured/]]]achieved with]]]-->a good alternative to this is additional curly brackets around a statement (<pre class="inline_code">if condition {statement}</pre>, like in Rust) or parens around a condition (<pre class="inline_code">if (condition) statement</pre>).<br />
</div>

</td></tr></table>
</body>
</html>