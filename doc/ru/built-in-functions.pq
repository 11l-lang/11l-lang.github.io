[[[H‘Встроенные функции’
]]]H‘Встроенные функции’


*‘print’(object = ‘’, end = "\n")
Выводит `object` и `end` в stdout.

*‘input’()
Читает строку из stdin и возвращает её (без символа новой строки).

*‘assert’(expression, message = ‘’)
Вызывает исключение AssertionError если выражение `expression` ложно.

*‘exit’(message = N)
Завершает текущий процесс. Если задан параметр `message`, он выводится в stderr.

*‘sleep’(secs)
Приостанавливает выполнение текущего потока на заданное количество секунд. Аргумент может быть числом с плавающей точкой для задания более точного времени приостановки.

*‘zip’(iterable1, iterable2)
Объединяет элементы из `iterable1` и `iterable2`.

*‘all’(iterable)
Возвращает истину (1B) если все элементы `iterable` истинны (или если `iterable` пуста).

*‘any’(iterable)
Возвращает истину (1B) если хотя бы один элемент `iterable` истинный. Если `iterable` пуста, возвращает ложь (0B).

*‘multiloop’(iterable1, iterable2 [,iterable3], function)
Эта функция практически эквивалентна следующему коду: {
#(11l)‘
F multiloop(iterable1, iterable2, function)
   V r = []
   L(el1) iterable1
      L(el2) iterable2
         r [+]= function(el1, el2)
   R r
’}

*‘multiloop_filtered’(iterable1, iterable2 [,iterable3], filter_function, function)
Эта функция практически эквивалентна следующему коду: {
#(11l)‘
F multiloop_filtered(iterable1, iterable2, filter_function, function)
   V r = []
   L(el1) iterable1
      L(el2) iterable2
         I filter_function(el1, el2)
            r [+]= function(el1, el2)
   R r
’}

*‘sum’(iterable)
Суммирует элементы `iterable` и возвращает итоговое значение.

*‘product’(iterable)
Умножает элементы `iterable` и возвращает итоговое значение.

*‘sorted’(iterable, key = N, reverse = 0B)
Возвращает отсортированный массив из элементов в `iterable`.
`key` задаёт функцию от одного аргумента, которая используется для извлечения ключа сравнения для каждого из элементов в `iterable`.
`reverse` — логическое значение. Если установлено в истину (1B), то элементы `iterable` сортируются таким образом, как будто каждое сравнение инвертировано.

*‘min’(arg1, arg2)
Возвращает наименьший из аргументов.
*‘min’(iterable)
Возвращает наименьший элемент `iterable`.

*‘max’(arg1, arg2)
Возвращает наибольший из аргументов.
*‘max’(iterable)
Возвращает наибольший элемент `iterable`.

*‘hex’(x)
Преобразует целое число в шестнадцатеричное в верхнем регистре.

*‘bin’(x)
Преобразует целое число в двоичное.

*‘rotl’(value, shift)
Циклически сдвигает `value` влево на `shift` разрядов.

*‘rotr’(value, shift)
Циклически сдвигает `value` вправо на `shift` разрядов.

‘Математические функции’{
*‘round’(number, ndigits = 0)
Возвращает `number` округлённое до `ndigits` знаков после точки.

*‘ceil’(x)
Возвращает наименьшее целое, которое больше либо равно `x`.

*‘floor’(x)
Возвращает наибольшее целое, которое меньше либо равно `x`.

*‘trunc’(x)
Возвращает `x` усечённое до целого.

*‘abs’(x)
Возвращает абсолютное значение.

*‘exp’(x)
Возвращает e в степени `x`, где e = 2.718281… это основание натурального логарифма.

*‘log’(x[, base])
С одним аргументом возвращает натуральный логарифм `x` (по основанию e).
С двумя аргументами возвращает логарифм `x` по основанию `base`, вычисляемый как `log(x)/log(base)`.

*‘log2’(x)
Возвращает логарифм `x` по основанию 2.

*‘log10’(x)
Возвращает логарифм `x` по основанию 10.

*‘pow’(x, y)
Возвращает `x` в степени `y`.
Рекомендуется использовать оператор `^` вместо данной функции.

*‘sqrt’(x)
Возвращает квадратный корень `x`.

*‘acos’(x)
Возвращает арккосинус `x` в радианах.

*‘asin’(x)
Возвращает арксинус `x` в радианах.

*‘atan’(x)
Возвращает арктангенс `x` в радианах.

*‘atan2’(x, y)
Возвращает `atan(y / x)`. Результат находится в интервале от `-pi` до `pi`.

*‘cos’(x)
Возвращает косинус `x` в радианах.

*‘sin’(x)
Возвращает синус `x` в радианах.

*‘tan’(x)
Возвращает тангенс `x` в радианах.

*‘degrees’(x)
Преобразует угол `x` из радиан в градусы.

*‘radians’(x)
Преобразует угол `x` из градусов в радианы.
}
