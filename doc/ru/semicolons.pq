[[[Н‘Точка с запятой и автоматическое склеивание строк’
]]]Н‘Точка с запятой’


Использовать точку с запятой для обозначения конца утверждений в 11l не требуется {точки с запятой могут быть использованы для размещения нескольких утверждений на одной строке, хотя это не рекомендуется}. Утверждения всегда завершаются посредством символа новой строки при условии что автоматическое склеивание строк (см. ниже) не сработало.


Н‘Автоматическое склеивание строк’


Вместо непонятных вещей вроде ‘Automatic Semicolon Insertion со сложными правилами’[http://www.ecma-international.org/ecma-262/6.0/index.html#sec-rules-of-automatic-semicolon-insertion] (которое, к тому же, иногда работает некорректно {
Примеры некорректной работы Automatic Semicolon Insertion:
1.‘В таком JavaScript коде:
#(JavaScript)‘
a = b + c
[d, e] = [e, d]
’
не происходит автоматической вставки точки с запятой, и такой код трактуется как:
#(JavaScript)‘
a = b + c[d, e] = [e, d]
’
’
2.‘Этот JavaScript код:
#(JavaScript)‘
return
  "something";
’
просто возвращает `undefined` (так как точка с запятой вставляется автоматически после `return`), но такой код в 11l вызовет ошибку при компиляции.’
})[[[,]]] в 11l используются в основном лишь 3 простых правила, которые [[[как легко понять программисту, так и реализовать в лексическом анализаторе]]]легко понятны и программисту и лексическому анализатору:
1.‘Если строка оканчивается на бинарный оператор, то она объединяется со следующей строкой:
#(11l)‘
I условие1 | // эта строка будет склеена со следующей, так как она оканчивается на бинарный оператор `|`
  условие2
   some_func()
’
’
2.‘Если строка начинается на бинарный оператор, то она объединяется с предыдущей строкой: {
При этом необходимо проверить, что это не унарный оператор:
#(11l)‘
a = b
++i // символ плюса в начале этой строки не должен быть принят за бинарный оператор `+`
’
}
#(11l)‘
some_variable = 2
              + 3 // эта строка будет склеена с предыдущей, так как она начинается на бинарный оператор `+`
’
’
3.‘И ‘также как в Python’[https://docs.python.org/3/reference/lexical_analysis.html#implicit-line-joining] для выражений в круглых и квадратных скобках символ новой строки игнорируется: [{
Также рассматривается возможность отказаться от данного правила для поддержки такого кода:
#(11l)‘
set_timeout(
            1.0,
            F ()
               alert(‘!’)
            ,
            0
           )
’
[[[Тогда]]]В этом случае 3-е правило [[[заменяется/]]]заменится на следующие 2 правила:
3. Если строка оканчивается на открывающую круглую скобку (`(`), квадратную (`[`) или запятую (`,`), то она объединяется со следующей строкой.
4. Если строка начинается на закрывающую круглую скобку (`)`) или квадратную (`]`), то она объединяется с предыдущей строкой.
}]
#(11l)‘
some_func( // так как в этой строке не закрыта скобка, все последующие строки будут склеиваться до тех пор,
   argument1,                                                               \\ пока скобка не будет закрыта
   argument2)
’
’

!‘Примечание: точка (`.`) не считается бинарным оператором, так как она также используется в качестве префикса переменных (смотри ‘Префиксы переменных’[./../prefixes]), и если требуется перенести вызов метода на следующую строку, тогда добавьте перед точкой обратный слэш:
#(11l)‘
result = obj.method1()
           \.method2()
’’
