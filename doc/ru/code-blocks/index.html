<html>
<head>
<meta charset="utf-8" />
<title>Блоки кода</title>
<base target="_blank">
<script type="text/javascript">
function spoiler(element, event)
{
    if (event.target.nodeName == 'A' || event.target.parentNode.nodeName == 'A' || event.target.onclick)//чтобы работали ссылки в спойлерах и спойлеры2 в спойлерах
        return;
    var e = element.firstChild.nextSibling.nextSibling;//element.getElementsByTagName('span')[0]
    e.previousSibling.style.display = e.style.display;//<span>…</span> must have inverted display style
    e.style.display = (e.style.display == "none" ? "" : "none");
    element.firstChild.style.fontWeight =
    element. lastChild.style.fontWeight = (e.style.display == "" ? "normal" : "bold");
    event.stopPropagation();
    //[-Чтобы была возможность выделять текст внутри раскрытого ‘скрытого текста’/спойлера, необходимо [скрытие/]закрытие спойлера делать не просто по нажатию левой кнопки мыши, а по отпусканию левой кнопки мыши при условии отсутствия движения курсора [мыши] после того, как была нажата левая кнопка мыши.-]
}
function spoiler2(element, event)
{
    element.nextSibling.style.display = (element.nextSibling.style.display == "none" ? "" : "none");
}
</script>
<style type="text/css">
body td {
    font-size: 14px;
    font-family: Verdana, sans-serif;
    line-height: 160%;
}
span.cu_brackets_b {
    font-size: initial;
    font-family: initial;
    font-weight: bold;
}
a {
    text-decoration: none;
    color: #6da3bd;
}
a:hover {
    text-decoration: underline;
    color: #4d7285;
}
h1, h2, h3, h4, h5, h6 {
    margin: 0;
    font-weight: 400;
}
h1 {font-size: 190%; line-height: 120%;}
h2 {font-size: 160%;}
h3 {font-size: 137.5%;}
h4 {font-size: 120%;}
h5 {font-size: 110%;}
h6 {font-size: 100%;}
td {text-align: justify; /*font-family: Tahoma, sans-serif;*/}
span.sq {color: gray; font-size: 0.8rem; font-weight: normal; /*pointer-events: none;*/}
span.sq_brackets {color: #BFBFBF;}
span.cu_brackets {cursor: pointer;}
span.cu {background-color: #F7F7FF;}
abbr {text-decoration: none; border-bottom: 1px dotted;}
pre {margin: 0;}
pre, code {font-family: 'Courier New'; line-height: normal}
ul, ol {margin: 11px 0 7px 0;}
ul li, ol li {padding: 7px 0;}
ul li:first-child, ol li:first-child {padding-top   : 0;}
ul  li:last-child, ol  li:last-child {padding-bottom: 0;}
table table {margin: 9px 0; border-collapse: collapse;}
table table th, table table td {padding: 6px 13px; border: 1px solid #BFBFBF;}
span.spoiler_title {
    color: #548eaa;
    cursor: pointer;
    border-bottom: 1px dotted;
}
div.spoiler_text {
    /*border: 1px dotted;*/
    margin: 5px;
    padding: 3px;
}
blockquote {
    margin: 0 0 7px 0;
    padding: 7px 12px;
}
blockquote:not(.re) {border-left:  0.2em solid #90ddaa; background-color: #fbfffb;}
blockquote.re       {border-right: 0.2em solid #90ddaa; background-color: #f4fff8;}
div.note {
    padding: 18px 20px;
    background: #ffffd7;
}
pre.code_block {padding: 6px 0;}
pre.inline_code {
    display: inline;
    padding: 0px 3px;
    border: 1px solid #E5E5E5;
    background-color: #FAFAFA;
    border-radius: 3px;
}
img {vertical-align: middle;}
</style>
</head>
<body>
<table width="55%" align="center"><tr><td>
<!--[[[Н‘Блоки кода’
]]]--><h3>Блоки кода</h3>
<br />
<br />
Также как и в Python, блоки кода в 11l выделяются посредством отступов (пробелов или табуляций):<br />
<style>
span.keyword {color: #0000FF; font-weight: bold;}
span.identifier {color: #00009F;}
span.string-literal {color: #800000;}
span.numeric-literal {color: #008000;}
span.constant {color: #008000;}
span.comment {color: #808080;}
</style><pre class="code_block">
<span class="keyword">F</span> <span class="identifier">sum</span>(<span class="identifier">a</span>, <span class="identifier">b</span>)
   <span class="keyword">R</span> <span class="identifier">a</span> + <span class="identifier">b</span>
</pre>
<span class="sq"><span class="sq_brackets">[</span>Здесь объявляется функция <pre class="inline_code">sum</pre>, возвращающая сумму двух её аргументов.<span class="sq_brackets">]</span></span><br />
<br />
Но 11l также поддерживает явное обозначение блоков посредством фигурных скобок, благодаря которому можно объявить эту же функцию без отступа:<br />
<pre class="code_block">
<span class="keyword">F</span> <span class="identifier">sum</span>(<span class="identifier">a</span>, <span class="identifier">b</span>)
{
<span class="keyword">R</span> <span class="identifier">a</span> + <span class="identifier">b</span>
}
</pre>
<br />
или в одну строку:<br />
<pre class="code_block">
<span class="keyword">F</span> <span class="identifier">sum</span>(<span class="identifier">a</span>, <span class="identifier">b</span>) {<span class="keyword">R</span> <span class="identifier">a</span> + <span class="identifier">b</span>}
</pre>
<br />
И такой стиль также поддерживается:<br />
<pre class="code_block">
<span class="keyword">F</span> <span class="identifier">sum</span>(<span class="identifier">a</span>, <span class="identifier">b</span>) {
   <span class="keyword">R</span> <span class="identifier">a</span> + <span class="identifier">b</span>
}
</pre>
<br />
И такой:<br />
<pre class="code_block">
<span class="keyword">F</span> <span class="identifier">sum</span>(<span class="identifier">a</span>, <span class="identifier">b</span>) {
<span class="keyword">R</span> <span class="identifier">a</span> + <span class="identifier">b</span>
}
</pre>
<br />
И такой:<br />
<pre class="code_block">
<span class="keyword">F</span> <span class="identifier">sum</span>(<span class="identifier">a</span>, <span class="identifier">b</span>)
{
   <span class="keyword">R</span> <span class="identifier">a</span> + <span class="identifier">b</span>
}
</pre>
<br />
<span class="spoiler_title" onclick="return spoiler2(this, event)">Мои мысли на тему ‘whitespace indentation to delimit code blocks’\‘выделение блоков кода с помощью отступов’/‘«двухмерного» синтаксиса Python-а’<br /></span><div class="spoiler_text" style="display: none">
«Двухмерный» синтаксис помимо избавления от <span class="sq"><span class="sq_brackets">[</span>мелкого<span class="sq_brackets">]</span></span> синтаксического <s>сахара</s>мусора <span class="cu_brackets" onclick="return spoiler(this, event)"><span class="cu_brackets_b">{</span><span>…</span><span class="cu" style="display: none">в форме <!--[[[точек с запятой, а также ]]точки с запятой не имеют отношения к «двухмерному» синтаксису (существует множество языков программирования с необязательными точками с запятой, но без выделения блоков кода с помощью отступов: JavaScript, Go, Swift, Scala, Groovy, Kotlin)]-->ключевых слов begin/end или фигурных скобок</span><span class="cu_brackets_b">}</span></span> даёт нечто большее, но что ещё так и не увидели/не поняли многие разработчики.<br />
Проиллюстрирую это на примере документации к языку Nemerle:<br />
<blockquote><a href="https://github.com/rsdn/nemerle/wiki/The-basics-(tutorial)#Rewriting_Line_Counter_without_the_loop"><i>https://github.com/rsdn/nemerle/wiki/...</i></a>:<br />
<br />
In Nemerle the if expression always need to have the else clause. It's done this way to avoid stupid bugs with dangling-else:<br />
<pre class="code_block">
<span class="comment">// C#, misleading indentation hides real code meaning</span>
<span class="keyword">if</span> (<span class="identifier">foo</span>)
   <span class="keyword">if</span> (<span class="identifier">bar</span>)
     <span class="identifier">m1</span> ();
<span class="keyword">else</span>
   <span class="identifier">m2</span> ();
</pre>
If you do not want the <pre class="inline_code">else</pre> clause, use <pre class="inline_code">when</pre> expression, as seen in the example.</blockquote>
<br />
Скорее всего, разработчики Nemerle просто <a href="https://semitwist.com/articles/article/view/nemerle-s-when-bad-idea-easily-solved" title="The mandatory 'else' is Nemerle's functional language inheritance showing">скопировали это из Haskell или Standard ML</a>, не став даже разбираться в причинах указанного "stupid bug with dangling-else". А причина вовсе не в неправильной логике if <span class="sq"><span class="sq_brackets">[</span>допускающем как отсутствие ветви else, так и её наличие<span class="sq_brackets">]</span></span>, и даже не в забытых фигурных скобочках, а в... расхождении в восприятии данного кода человеком-программистом и компилятором. Человек воспринимает границы блоков визуально, <!--[[[в первую очередь ]]]-->посредством отступов, а компилятор — посредством <span class="sq"><span class="sq_brackets">[</span>малоприметных для человека<span class="sq_brackets">]</span></span> символов, причём компилятор <span class="sq"><span class="sq_brackets">[</span>языков C/C++, C#, Java, Nemerle и др.<span class="sq_brackets">]</span></span> объединяет все "пробельные" символы <span class="sq"><span class="sq_brackets">[</span>разделители<span class="sq_brackets">]</span></span>, и, таким образом, напрочь игнорирует отступы. Вот в этом и заключается <b>корень проблемы — компилятор и человек видят <span class="sq"><span class="sq_brackets">[</span>такой<span class="sq_brackets">]</span></span> код по-разному</b>.<br />
Поэтому меня удивляют люди, которые ‘‘жалуются на трудность и непривычность чтения такого кода’’, а также возражения, что ‘‘при изменении лишь отступа, меняется логика работы кода’’. Так в этом и состоит весь смысл отступо-зависимой семантики! Ведь такое изменение отступа будет хорошо заметно человеку (особенно привыкшему к такой семантике).<br />
А для желающих временно добавить if, включающий в себя большой блок кода <span class="sq"><span class="sq_brackets">[</span>который не хочется сдвигать лишний раз<span class="sq_brackets">]</span></span>, я считаю, что вполне можно оставить поддержку фигурных скобок:<br />
<pre class="code_block">
<span class="keyword">if</span> <span class="identifier">foo</span> <span class="comment">// временно добавленное условие</span>
{
<span class="identifier">m1</span>() <span class="comment">// нет отступа относительно if foo</span>
...
<span class="keyword">if</span> <span class="identifier">bar</span>
    <span class="identifier">m2</span>()
    ...
...
}
</pre>
<br />
<blockquote><a href="http://compiler.su/dvukhmernyj-sintaksis-python.php"><i>http://compiler.su/dvukhmernyj-sintaksis-python.php</i></a>:<br />
... заканчиваются двоеточием, без которого можно обойтись.</blockquote>
Согласен.<br />
По сути, это двоеточие в Python не имеет смысла, так как есть операторы (if, <!--[[[switch, ]]]-->for/while, def, class и т.д.), которые требуют всегда нового scope, и одного признака ‘‘новая строка с отступом’’ вполне достаточно.<br />
<span class="spoiler_title" onclick="return spoiler2(this, event)">Кстати, весьма интересна история появления этого двоеточия.<br /></span><div class="spoiler_text" style="display: none">
<blockquote><a href="http://python-history.blogspot.com/2011/07/karin-dewar-indentation-and-colon.html" title="Karin Dewar, Indentation and the Colon"><i>http://python-history.blogspot.com/2011/07/...</i></a>:<br />
<br />
In 1978, in a design session in a mansion in Jabłonna (Poland), Robert Dewar, Peter King, Jack Schwartz and Lambert were comparing various alternative proposed syntaxes for B<!--[[[, by comparing (buggy) bubble sort implementations written down in each alternative]]]-->... Since they couldn't agree, Robert Dewar's wife was called from her room and asked for her opinion<!--[[[, like a modern-day Paris asked to compare the beauty of Hera, Athena, and Aphrodite]]]-->... But after the first version was explained to her, she remarked: "You mean, in the line where it says: 'FOR i ... ', that it has to be done for the lines that follow; not just for that line?!" And here the scientists realized that the misunderstanding would have been avoided if there had been a colon at the end of that line.<br />
</blockquote>
То есть, scientists, разработчики языка программирования, прислушались к мнению<!--[[[/высказыванию]]]--> <!--[[[женщины/]]]-->человека, не имеющего никакого отношения к программированию? Они хотели таким образом упростить понимание языка для новичков? Но новичком программист остаётся только короткое время в начале своего пути, а лишние двоеточия наблюдать и набирать придётся и дальше. Не думаю, что так уж сложно <!--[[[будет ]]]-->привыкнуть к их отсутствию...<br />
</div>
Единственное полезное применение двоеточия — однострочные if'ы (<pre class="inline_code">if условие: выражение</pre>) и циклы, но <!--[[[это вполне можно разрулить /]]]-->выйти из положения можно с помощью обозначения scope в фигурных скобках (запись <pre class="inline_code">if условие {выражение}</pre>) как в Rust, либо взяв условие в скобки (<pre class="inline_code">if (условие) выражение</pre>).<br />
В крайнем случае, я считаю, вполне возможно это двоеточие <!--[[[отображать по настройке в IDE]]]-->вынести в настройки проекта. И команды разработчиков, которые примут у себя в качестве стандарта <span class="sq"><span class="sq_brackets">[</span>кодирования<span class="sq_brackets">]</span></span> запись с двоеточием, будут писать с двоеточием, а кто не хочет <span class="sq"><span class="sq_brackets">[</span>следовать такому стандарту<span class="sq_brackets">]</span></span> — пусть пишут без двоеточия. На уровне компилятора реализовать пропуск двоеточия <i>в конце строки</i> для <!--[[[некоторых/]]]-->нескольких операторов <!--[[[задача элементарная]]]-->совсем несложно.<br />
Или можно на уровне IDE сделать опциальное отображение двоеточия в конце строк, начинающихся на I/if, E/else, F/fn, L/loop, S/switch, T/type и т.д.<br />
</div>

</td></tr></table>
</body>
</html>