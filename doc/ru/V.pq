[[[H‘V/var’
]]]H‘Ключевое слово V/var’


Данное ключевое слово используется для того, чтобы [[[добавить/]]]объявить переменную в текущем блоке кода[[[ области видимости]]]:
#(11l)‘
V variable_name = value
’

Можно объявить группу переменных, инициализированных кортежем:
#(11l)‘
F get_row_column() // функция, возвращающая кортеж
   ...
   R (row, col)
...
V (row, col) = get_row_column() // аналогично такой записи: `V rc = get_row_column(); V row = rc[0]; V col = rc[1]`
’

Также допустимо частичное объявление:
#(11l)‘
(V row2, col) = get_row_column() // `col` уже объявлена выше, `row2` создаётся/объявляется в этой строке
’
или:
#(11l)‘
(row, V col2) = get_row_column() // `row` уже объявлена выше, `col2` создаётся/объявляется в этой строке
’

Чтобы объявить и назначить некоторое значение сразу нескольким переменным [[[одновременно]]] используйте такую запись ({на данный момент не поддерживается [{зачем тогда писать об этом здесь в документации? затем, чтобы при подготовке к [[[новой реализации [полноценном компиляторе]]]]реализации полноценного компилятора иметь представление обо всех требуемых фичах (включая те, которые транспайлер 11l → C++ не поддерживает)}]}):
#(11l)‘
V a = V b = 0
’

Для объявления константы используйте `-V`/`-var`:
#(11l)‘
-V constant_name = value
’
[{`-` с одной стороны означает постоянство (так обозначается постоянный ток), а с другой — противоположность[https://ru.wikipedia.org/wiki/Противоположное_число] (<не переменная\variable> есть <константа>).}]

Чтобы сократить количество ключевых слов `V`/`var`, можно использовать дополнительный scope. Например, такой код:
#(11l)‘
-V
   n_rows = 10
   n_cols = 10
   grid_size = n_rows * n_cols
   min_words = 25
’
эквивалентен такому:
#(11l)‘
-V n_rows = 10
-V n_cols = 10
-V grid_size = n_rows * n_cols
-V min_words = 25
’

H(-1)‘`V?` и `V&`’

#(11l)‘
V? i = ‘str’.find(‘s’)

F print_set(DefaultDict[Int, Set[Int]] &map; key)
   V& s = map[key] // `V s = map[key]` писать нельзя (но можно `V s = copy(map[key])`)
’

H(-1)‘`I V`’

#(11l)‘
I (V&? sheep = Sheep?(animal)) != N
   print(sheep.some_sheep_prop)
’
можно сократить {
#(11l)‘I -V sheep = Sheep?(animal)’ также излишне, т.к. если `animal` имеет тип `-Animal`, то `sheep` будет константой в любом случае [подобно `auto&` в C++ — `const auto&` в данном случае не обязательно].
} до:
#(11l)‘
I V sheep = Sheep?(animal)
   ...
’
т.к. в 11l нет скрытого/неявного копирования[[[и разделения]]].

И также как в Swift {
>[https://stackoverflow.com/questions/25828301/how-is-swift-if-let-evaluated <- google:‘swift "if let"’]:‘you can write:
#‘
if let name = optionalName {
’
but not
#‘
if (let name = optionalName) {
’
’[[[}}]]]} запись #(11l)‘I (V sheep = Sheep?(animal)) {...}’ запрещена.

Однако, в 11l также можно писать так:
#(11l)‘
I T(animal) == Sheep // или `I T(animal) >= Sheep`
   print(animal.some_sheep_prop)
’

Также обратите внимание[[[ на следующее]]]:
#(11l)‘
I V v = ... // `v` ведёт себя как константная ссылка, поэтому
   v = ...  // так писать нельзя

// А если хочется иметь возможность писать `v = ...`, тогда:
I V& v = ...   // пишите так
I V v = copy(...) // или так
’
[Это/‘такое поведение’ может показаться странным, но подобный прецедент в 11l уже есть: `L(el)` vs `L(&el)`, а также аргументы функций (которые неизменяемы ‘по умолчанию’/‘без квалификаторов’).
Впрочем, несмотря на запрет `v = ...` вызывать неконстантные методы `v` допускается (в целях удобства).]

H(-1)‘`V E`’

Вместо:
#(11l)‘
V&? el = map.get(key)
I el == N
   print(‘Key <’key‘> is not found!’)
   R
’
лучше писать:
#(11l)‘
V& el = map.get(key) E
   print(‘Key <’key‘> is not found!’)
   R
’
Данный синтаксис был навеян `guard let` {однако в 11l нет аналога `guard <условие>`, т.к. можно использовать просто `I !(<условие>)`} из Swift, но он достаточно логичный, т.к.
#(11l)‘
V& el = map.get(key)!
’
то же самое, что
#(11l)‘
V& el = map.get(key) E
   X.throw NullPointerException()
’
